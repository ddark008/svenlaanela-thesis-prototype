package $original.packageName;

import javassist.*;
import javassist.expr.*;

public class $original.cbpSimpleName implements org.zeroturnaround.javassist.annotation.processor.JavassistClassBytecodeProcessor {

  private static final String COMPANION_FIELD = "__companion";
  private static final String ORIGINAL_FIELD = "__original";
  private static final String ORIGINAL_METHOD = "__original";
  private static final String ORIGINAL_AWARE_CLASS = "org.zeroturnaround.javassist.annotation.OriginalAware";
	
  public void process(ClassPool cp, ClassLoader cl, final CtClass ctClass) throws Exception {
    ctClass.addField(CtField.make("final $companion.name "+COMPANION_FIELD+" = new $companion.name ();" , ctClass));
    
    //TODO: convert companion to inner class to access private fields/methods
    CtClass companionClass = cp.get("$companion.name");
    companionClass.addField(CtField.make("private $original.name "+ORIGINAL_FIELD+" = null;", companionClass));
    companionClass.addInterface(cp.get(ORIGINAL_AWARE_CLASS));
    companionClass.addMethod(CtMethod.make("public void setOriginal(Object original) { "+ORIGINAL_FIELD+" = ($original.name) original; }", companionClass));
      
    for (CtMethod method : companionClass.getDeclaredMethods()) {
      // create a copy of the original method body for all methods that are overriden in the companion class 
      // and redirect the original method to call the method defined in the companion class (which will call
      // the original method body copy if required.
      try {
        CtMethod originalMethod = ctClass.getDeclaredMethod(method.getName(), method.getParameterTypes());
        CtMethod originalCopy = CtNewMethod.copy(originalMethod, method.getName() + ORIGINAL_METHOD, ctClass, null);
        System.out.println("Created copy for original: "+originalMethod.getName()+"() -> "+originalCopy.getName()+"()");
        ctClass.addMethod(originalCopy);
        String target = Modifier.isStatic(method.getModifiers()) ? companionClass.getName() : COMPANION_FIELD;
        if ("void".equals(originalMethod.getReturnType().getName())) {
          originalMethod.setBody("{ "+target+"."+method.getName()+"($$);}");
        } else {
          originalMethod.setBody("{ return "+target+"."+method.getName()+"($$);}");
        }
      } catch (NotFoundException ignored) {} // expected, not all methods of the companion exist in the original
      
      // The companion class was compiled against a mirror of the original, overwrite all method and field accesses
      // to invoke the original 
      method.instrument(new ExprEditor() {
        public void edit(MethodCall m) throws CannotCompileException {
          try {
            if (m.getClassName().equals(ctClass.getName() + "_Mirror")) {
              System.out.println("Updated method call target for companion: "+m.getClassName()+"."+m.getMethodName()+"() -> "+ctClass.getName()+"."+m.getMethodName()+"__original()");
              String target = Modifier.isStatic(m.getMethod().getModifiers()) ? ctClass.getName() : ORIGINAL_FIELD;
              if ("void".equals(m.getMethod().getReturnType().getName())) {
                m.replace("{ "+target+"." + m.getMethodName() + ORIGINAL_METHOD+"($$); }");
              } else {
                m.replace("{ $_ = "+target+"." + m.getMethodName() + ORIGINAL_METHOD+"($$); }");
              }
            }
          } catch (NotFoundException e) { e.printStackTrace();}
        }
        public void edit(FieldAccess f) throws CannotCompileException {
          try {
        	if (f.getField().getDeclaringClass().getName().equals(ctClass.getName() +"_Mirror")) {
              System.out.println("Updating field access: "+f.getField().getDeclaringClass().getName()+"."+f.getFieldName()+" -> "+ctClass.getName()+"."+f.getFieldName());
              String target = Modifier.isStatic(f.getField().getModifiers()) ? ctClass.getName() : ORIGINAL_FIELD;
              f.replace("{ $_ = "+target+"." + f.getFieldName() +"; }");
        	}
          } catch (NotFoundException e) { e.printStackTrace(); }
        }
      });
    }
      
    for (CtConstructor method : ctClass.getDeclaredConstructors()) {
      method.insertAfter("{ (("+ORIGINAL_AWARE_CLASS+")"+COMPANION_FIELD+").setOriginal(this); }");
    }
      
      // debug
      // companionClass.writeFile();
      // ctClass.defrost();
      // ctClass.writeFile();
      
    companionClass.toClass(); // TODO: NB! it might be incorrect to call this in the context of the ContextClassLoader of a given thread.
  }
}