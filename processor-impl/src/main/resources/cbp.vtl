package $original.packageName;

import javassist.*;
import javassist.expr.*;

public class $original.cbpSimpleName implements org.zeroturnaround.javassist.annotation.processor.JavassistClassBytecodeProcessor {

  public void process(ClassPool cp, ClassLoader cl, final CtClass ctClass) throws Exception {
    ctClass.addField(CtField.make("final $companion.name __companion = new $companion.name ();" , ctClass));
    
    //TODO: convert companion to inner class to access private fields/methods
    CtClass companionClass = cp.get("$companion.name");
    companionClass.addField(CtField.make("$original.name __original = null;", companionClass));
    companionClass.addInterface(cp.get("org.zeroturnaround.javassist.annotation.OriginalAware"));
    companionClass.addMethod(CtMethod.make("public void setOriginal(Object original) { __original = ($original.name) original; }", companionClass));
      
    for (CtMethod method : companionClass.getDeclaredMethods()) {
      // create a copy of the original method body for all methods that are overriden in the companion class 
      // and redirect the original method to call the method defined in the companion class (which will call
      // the original method body copy if required.
      try {
        CtMethod originalMethod = ctClass.getDeclaredMethod(method.getName(), method.getParameterTypes());
        CtMethod originalCopy = CtNewMethod.copy(originalMethod, method.getName() + "__original", ctClass, null);
        System.out.println("Created copy for original: "+originalMethod.getName()+"() -> "+originalCopy.getName()+"()");
        ctClass.addMethod(originalCopy);
        if ("void".equals(originalMethod.getReturnType().getName())) {
          originalMethod.setBody("{ __companion."+method.getName()+"($$);}");
        } else {
          originalMethod.setBody("{ return __companion."+method.getName()+"($$);}");
        }
      } catch (NotFoundException ignored) {} // expected, not all methods of the companion exist in the original
      
      // The companion class was compiled against a mirror of the original, overwrite all method and field accesses
      // to invoke the original 
      method.instrument(new ExprEditor() {
        public void edit(MethodCall m) throws CannotCompileException {
          if (m.getClassName().equals(ctClass.getName() + "_Mirror")) {
            System.out.println("Updated method call target for companion: "+m.getClassName()+"."+m.getMethodName()+"() -> "+ctClass.getName()+"."+m.getMethodName()+"__original()");
            try {
              if ("void".equals(m.getMethod().getReturnType().getName())) {
                m.replace("{ __original." + m.getMethodName() + "__original($$); }");
              } else {
                m.replace("{ $_ = __original." + m.getMethodName() + "__original($$); }");
              }
            } catch (Exception e) { e.printStackTrace();}
          }
        }
        public void edit(FieldAccess f) throws CannotCompileException {
          if (f.getClassName().equals(ctClass.getName() +"_Mirror")) {
            System.out.println("Updating field access: "+f.getClassName()+"."+f.getFieldName()+" -> "+ctClass.getName()+"."+f.getFieldName());
            f.replace("{ $_ = __original." + f.getFieldName() +"; }");
          }
        }
      });
    }
      
    for (CtConstructor method : ctClass.getDeclaredConstructors()) {
      method.insertAfter("{ ((org.zeroturnaround.javassist.annotation.OriginalAware)__companion).setOriginal(this); }");
    }
      
      // debug
      // companionClass.writeFile();
      // ctClass.defrost();
      // ctClass.writeFile();
      
    companionClass.toClass(); // TODO: NB! it might be incorrect to call this in the context of the ContextClassLoader of a given thread.
  }
}