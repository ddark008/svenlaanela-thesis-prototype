package $original.packageName;

import java.util.*;
import javassist.*;
import javassist.expr.*;
import javassist.bytecode.*;
import org.zeroturnaround.javassist.annotation.Modify;
import org.zeroturnaround.javassist.annotation.Patches;
import org.zeroturnaround.javassist.annotation.Transformer;

@Transformer("$original.name")
public class $original.cbpSimpleName implements org.zeroturnaround.javassist.annotation.processor.wiring.JavassistClassBytecodeProcessor {

  private static final String EXTENSION_FIELD = "__companion";
  private static final String ORIGINAL_FIELD = "__original";
  private static final String ORIGINAL_METHOD = "__original";
  private static final String ORIGINAL_AWARE_CLASS = "org.zeroturnaround.javassist.annotation.OriginalAware";
  
  public void process(final ClassPool cp, final ClassLoader cl, final CtClass originalClass) throws Exception {
    originalClass.addField(CtField.make("final $extension.name "+EXTENSION_FIELD+" = new $extension.name ();" , originalClass));
    
    CtClass extensionClass = cp.get("$extension.name");
    extensionClass.addField(CtField.make("private $original.name "+ORIGINAL_FIELD+" = null;", extensionClass));
    extensionClass.addInterface(cp.get(ORIGINAL_AWARE_CLASS));
    extensionClass.addMethod(CtMethod.make("public void setOriginal(Object original) { "+ORIGINAL_FIELD+" = ($original.name) original; }", extensionClass));
      
    for (final CtMethod extensionMethod : extensionClass.getDeclaredMethods()) {
      // for all methods that are overriden in the companion class, create a copy of the original method
      // and redirect the original method to call the method defined in the companion class (which will call
      // the created copy of the original method if required.
      
      CtMethod originalMethod = null;
      CtMethod originalCopy = null;
      try {
        originalMethod = originalClass.getDeclaredMethod(extensionMethod.getName(), extensionMethod.getParameterTypes()); // throws NotFoundException if not a method override!
        if (extensionMethod.hasAnnotation(Modify.class)) {
          originalMethod.setModifiers(extensionMethod.getModifiers());
        } else {
          //
        }
        originalCopy = CtNewMethod.copy(originalMethod, extensionMethod.getName() + ORIGINAL_METHOD, originalClass, null);
        System.out.println("Copy method: "+originalMethod.getName()+"() -> "+originalCopy.getName()+"()");
        originalClass.addMethod(originalCopy);
        String target = Modifier.isStatic(extensionMethod.getModifiers()) ? extensionClass.getName() : EXTENSION_FIELD;
        if ("void".equals(originalMethod.getReturnType().getName())) {
          originalMethod.setBody("{ "+target+"."+extensionMethod.getName()+"($$);}");
        } else {
          originalMethod.setBody("{ return "+target+"."+extensionMethod.getName()+"($$);}");
        }
      } catch (NotFoundException ignored) {} // expected, not all methods of the companion exist in the original
      
      // Find anonymous inner classes of types MethodCall instantiated within this method
      final List<String> instrumentClassNames = new ArrayList<String>();
      extensionMethod.instrument(new ExprEditor() {
        public void edit(final NewExpr c) throws CannotCompileException {
          try {
            String className = c.getClassName();
            if (Arrays.asList(cp.get(className).getInterfaces()).contains(cp.get(org.zeroturnaround.javassist.annotation.MethodCall.class.getName()))){
              instrumentClassNames.add(className);
            }
          } catch (NotFoundException ignored) { ignored.printStackTrace(); }
        }
      });
      
      // The companion class was compiled against a mirror of the original, overwrite all method and field accesses
      // to invoke the original
      final CtMethod finalOriginalCopy = originalCopy;
      extensionMethod.instrument(new ExprEditor() {
        public void edit(final MethodCall m) throws CannotCompileException {
          try {
        	if (m.getClassName().equals(originalClass.getName() + "_Mirror")) {
              // Register a method instrument/edit for the body in methods that call Instrument
        	  if (m.getSignature().contains(org.zeroturnaround.javassist.annotation.MethodCall.class.getName().replace('.', '/'))) {
            	  /* extract method */
            	  for (final String instrumentClassName : instrumentClassNames) {
            	    System.out.println("Instrumenting method:" + finalOriginalCopy.getSignature() + ", class:" +instrumentClassName);
                    CtClass instrumentClass = cp.get(instrumentClassName);
                    for (final CtMethod instrumentMethod : instrumentClass.getDeclaredMethods()) {
                      final String instrumentName = instrumentMethod.getName();
                      final CtClass instrumentReturnType = instrumentMethod.getReturnType();
                      final List<CtClass> instrumentParameterTypes = new ArrayList<CtClass>(Arrays.asList(instrumentMethod.getParameterTypes()));
                      final CtClass instrumentTargetType = instrumentParameterTypes.remove(0);
                      // Add an instrumenter as defined in the anonymous class
                      finalOriginalCopy.instrument(new ExprEditor() {
                        public void edit(MethodCall m2) throws CannotCompileException {
                          try {
                            System.out.println("Replace: "+finalOriginalCopy.getSignature()+" " + m2.getClassName() +", " + m2.getMethodName());
                            if (m2.getClassName().equals(instrumentTargetType.getName()) && m2.getMethodName().equals(instrumentName) && Arrays.equals(m2.getMethod().getParameterTypes(), instrumentParameterTypes.toArray())) {
                              //TODO: hacky solution, need to save the instance somewhere
                              //TODO: does not support redirecting method call to a method inside the same class/inside a mirror
                              m2.replace("$_ = new "+instrumentClassName+"(__companion)."+instrumentName+"($0, $$);"); // TODO: hacky solution, need to save the instance somewhere.
                            }
                          } catch (NotFoundException ignored) { ignored.printStackTrace(); }
                        }
                      });
                    }
                  }
            	  m.replace("");
            	} else {
            	  /* extract method rewireMethodCallFromMirrorToOriginal */
                  System.out.println("Rewiring method call in extension: "+m.getClassName()+"."+m.getMethodName()+"() -> "+originalClass.getName()+"."+m.getMethodName()+"__original()");
                  
                  CtMethod originalMethod = originalClass.getMethod(m.getMethod().getName(), m.getMethod().getSignature());
                  
                  // If the modifier for the original method is private, we need to create a synthetic
                  // accessor for it. Ignore already existing synthetic methods and just create
                  // new ones for things that we need.
                  String syntheticMethodName = null;
                  if (Modifier.isPrivate(originalMethod.getModifiers())) {
                	syntheticMethodName = createSyntheticAccessor(originalClass, originalMethod);
                  }
                  
                  if (syntheticMethodName != null) {
                	if ("void".equals(m.getMethod().getReturnType().getName())) {
                	  m.replace("{ "+originalClass.getName()+"." + syntheticMethodName +"("+ORIGINAL_FIELD+", $$); }");
                	} else {
                      m.replace("{ $_ = "+originalClass.getName()+"." + syntheticMethodName +"("+ORIGINAL_FIELD+", $$); }");
                  	}
                  } else {
                    String targetMethodName = m.getMethodName(); 
                    String target = Modifier.isStatic(m.getMethod().getModifiers()) ? originalClass.getName() : ORIGINAL_FIELD;
      	            if ("void".equals(m.getMethod().getReturnType().getName())) {
      	              m.replace("{ "+target+"." + m.getMethodName() + ORIGINAL_METHOD+"($$); }");
      	            } else {
      	              m.replace("{ $_ = "+target+"." + m.getMethodName() + ORIGINAL_METHOD+"($$); }");
      	            }
                  }
                }
        	}
          } catch (NotFoundException e) { e.printStackTrace();}
        }
        public void edit(FieldAccess f) throws CannotCompileException {
          try {
        	if (f.getField().getDeclaringClass().getName().equals(originalClass.getName() +"_Mirror")) {
        	  /* extract method rewireFieldAccessFromMirrorToOriginal */
              System.out.println("Rewiring field access in extension: "+f.getField().getDeclaringClass().getName()+"."+f.getFieldName()+" -> "+originalClass.getName()+"."+f.getFieldName());
              CtField originalField = originalClass.getDeclaredField(f.getFieldName());
              
              // If the modifier for the original field is private, we need to create a synthetic
              // accessor for it. Ignore already existing synthetic methods and just create
              // new ones for things that we need.
              String syntheticMethodName = null;
              if (Modifier.isPrivate(originalField.getModifiers())) {
                syntheticMethodName = createSyntheticAccessor(originalClass, originalField);
              }
              
              if (syntheticMethodName != null) {
                if (f.isReader()) {
                  f.replace("{ $_ = "+originalClass.getName()+"."+syntheticMethodName+"("+ORIGINAL_FIELD+")}");
                }
                if (f.isWriter()) {
                  f.replace("{ "+originalClass.getName()+"."+syntheticMethodName+"("+ORIGINAL_FIELD+", $1)}");
                }
              } else {
                String target = Modifier.isStatic(f.getField().getModifiers()) ? originalClass.getName() : ORIGINAL_FIELD;
                if (f.isReader()) {
                  f.replace("{ $_ = "+target+"." + f.getFieldName() +"; }");
                }
                if (f.isWriter()) {
                  f.replace("{"+target+"."+f.getFieldName()+" = $1; }");
                }
              }
        	}
          } catch (NotFoundException e) { e.printStackTrace(); }
        }
      });
    }

    // Static block of extension is executed after original static block
    CtConstructor extStaticInitializer = extensionClass.getClassInitializer();
    if (extStaticInitializer != null) {
      System.out.println("STATIC INIT: " + extStaticInitializer.toString());
      rewireExtensionClassMethodsToCallOriginal(extStaticInitializer, originalClass);
      CtConstructor origStaticInitializer = originalClass.getClassInitializer();
      if (origStaticInitializer == null) {
        originalClass.makeClassInitializer().setBody(extStaticInitializer, null);
      } else {
        origStaticInitializer.insertAfter(extStaticInitializer.toString());
      }
    }
    
    

    for (CtConstructor extensionConstructor : extensionClass.getDeclaredConstructors()) {
       
    }
    for (CtConstructor originalConstructor : originalClass.getDeclaredConstructors()) {
      originalConstructor.insertAfter("{ (("+ORIGINAL_AWARE_CLASS+")"+EXTENSION_FIELD+").setOriginal(this); }");
    }
    
    for (CtField extensionField : extensionClass.getDeclaredFields()) {
      if (extensionField.hasAnnotation(Modify.class)) {
        CtField originalField = originalClass.getField(extensionField.getName());
        originalField.setModifiers(extensionField.getModifiers());
      } else {
        
      }
    }

    extensionClass.toClass(); // TODO: NB! it might be incorrect to call this in the context of the ContextClassLoader of a given thread.
  }
  
  private void rewireExtensionClassMethodsToCallOriginal(final CtBehavior extensionClassExecutable, final CtClass originalClass) throws CannotCompileException, NotFoundException {
    System.out.println("Rewiring extension class executable to call original: "+extensionClassExecutable.getDeclaringClass().getName()+"."+extensionClassExecutable.getName()+extensionClassExecutable.getSignature());
    extensionClassExecutable.instrument(new ExprEditor() {
      public void edit(MethodCall m) throws CannotCompileException {
        try {
          if (m.getClassName().equals(originalClass.getName() + "_Mirror")) { // is a call on a mirror?
            System.out.println(originalClass.getName()+"."+m.getMethodName() + m.getSignature());
            String target = Modifier.isStatic(m.getMethod().getModifiers()) ? originalClass.getName() : ORIGINAL_FIELD;
            if ("void".equals(m.getMethod().getReturnType().getName())) {
              m.replace("{ "+target+"." + m.getMethodName() + ORIGINAL_METHOD+"($$); }");
            } else {
              m.replace("{ $_ = "+target+"." + m.getMethodName() + ORIGINAL_METHOD+"($$); }");
            }
          }
        } catch (NotFoundException e) {
          e.printStackTrace(); // TODO
        }
      }
      
      public void edit(FieldAccess f) throws CannotCompileException {
        try {
          if (f.getField().getDeclaringClass().getName().equals(originalClass.getName() +"_Mirror")) { // is a call on a mirror?
            System.out.println(originalClass.getName()+"."+f.getFieldName());
            String target = Modifier.isStatic(f.getField().getModifiers()) ? originalClass.getName() : ORIGINAL_FIELD;
            if (f.isReader()) {
              f.replace("{ $_ = "+target+"." + f.getFieldName() +"; }");
            }
            if (f.isWriter()) {
              f.replace("{"+target+"."+f.getFieldName()+" = $1; }");
            }
          }
        } catch (NotFoundException e) {
          e.printStackTrace(); //TODO
        }
      }
    });
  }
  
  private String createSyntheticAccessor(CtClass originalClass, CtField originalField) throws NotFoundException, CannotCompileException {
    System.out.println("creating a synthetic getter/setter for: " + originalField.getType().getName() + originalField.getName());
    String syntheticMethodName = getUniqueSyntheticMethodName();
    String syntheticGetterDeclaration = 
        "static " +originalField.getType().getName()+" "+syntheticMethodName+"("+originalClass.getName()+" instance) {"+
          "return instance."+originalField.getName()+";"+
        "}";
    System.out.println(syntheticGetterDeclaration);
    originalClass.addMethod(CtNewMethod.make(syntheticGetterDeclaration, originalClass));
        
    String syntheticSetterDeclaration = 
        "static void "+syntheticMethodName+"("+originalClass.getName()+" instance, "+originalField.getType().getName()+" value) {"+
          "instance."+originalField.getName()+" = value;"+
        "}";
    System.out.println(syntheticSetterDeclaration);
    originalClass.addMethod(CtNewMethod.make(syntheticSetterDeclaration, originalClass));
    return syntheticMethodName;
  }
  
  private String createSyntheticAccessor(CtClass originalClass, CtMethod originalMethod) throws NotFoundException, CannotCompileException {
    System.out.println("creating a synthetic method for: " + originalMethod.getName() + originalMethod.getSignature());
    String syntheticMethodName = getUniqueSyntheticMethodName();
    String argsString = toArgsString(toClassNames(originalMethod.getParameterTypes()), true);
    String argsStringWithoutTypes = toArgsString(toClassNames(originalMethod.getParameterTypes()), false);
    String syntheticMethodArgs = originalClass.getName()+ " instance" + (!argsString.isEmpty() ? (", " +argsString) : "");
    String syntheticMethodDeclaration = 
      "static "+originalMethod.getReturnType().getName()+" "+syntheticMethodName+"("+syntheticMethodArgs+") {"+
        "return instance."+originalMethod.getName()+ORIGINAL_METHOD+"("+argsStringWithoutTypes+");"+
      "}";
    System.out.println(syntheticMethodDeclaration);
    originalClass.addMethod(CtNewMethod.make(syntheticMethodDeclaration, originalClass));
    return syntheticMethodName;
  }
  
  private String[] toClassNames(CtClass[] ctClasses) {
    String[] result = new String[ctClasses.length];
    for (int i = 0; i < ctClasses.length; i++) {
      result[i] = ctClasses[i].getName();
    }
    return result;
  }
  
  private String toArgsString(String[] argClasses, boolean includeTypes) {
    if (argClasses == null || argClasses.length == 0) {
      return "";
    } else {
      String result = "";
      boolean addComma = false;
      for (int i = 0; i < argClasses.length; i++) {
        result += addComma ? ", " : "";
        result += includeTypes ? argClasses[i] + " " : "";
        result += "$synarg"+(i+1);
        addComma = true;
      }
      return result;
    }
  }
  
  // should be good enough for avoiding collisions
  private int syntheticMethodCounter = 9999;
  private String getUniqueSyntheticMethodName() {
    return "access$" + syntheticMethodCounter--;
  }
}